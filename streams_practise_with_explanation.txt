refresher:
intermediate operations
Common Stream<T> intermediate methods
filter(Predicate)
map(Function)
flatMap(Function)
distinct()
sorted()
sorted(Comparator)
peek(Consumer)
limit(long)
skip(long)
takeWhile(Predicate)        // Java 9+
dropWhile(Predicate)        // Java 9+
Primitive streams (IntStream, LongStream, DoubleStream)
mapToInt()
mapToLong()
mapToDouble()
boxed()

A) Terminal methods returning Optional
findFirst()
findAny()
min(Comparator)
max(Comparator)
reduce(BinaryOperator) 

B) Terminal methods returning a value
count()                    // long
collect(Collector)         // List, Set, Map, etc.
reduce(identity, accumulator)
reduce(identity, accumulator, combiner)
toArray()
sum()      // primitive streams
average()  // OptionalDouble
min()      // OptionalInt, OptionalLong, OptionalDouble (primitive streams)
max()  // OptionalInt, OptionalLong, OptionalDouble (primitive streams)

Terminal methods returning boolean
anyMatch(Predicate)
allMatch(Predicate)
noneMatch(Predicate)

Terminal methods returning void
forEach(Consumer)
forEachOrdered(Consumer)

3️⃣ Methods that return Optional (IMPORTANT ⭐)
Stream<T>
findFirst()
findAny()
min()
max()
reduce()

Primitive streams
average()          // OptionalDouble
min()              // OptionalInt / OptionalLong / OptionalDouble
max()              // OptionalInt / OptionalLong / OptionalDouble
findFirst()
findAny()


Last repeating character using streams

 find the result.Javaimport java.util.LinkedHashMap;
import java.util.Map;
import java.util.function.Function;
import java.util.stream.Collectors;

public class LastNonRepeating {
    public static void main(String[] args) {
        String input = "JavaStreamJ";

        Character result = input.chars()
            .mapToObj(c -> (char) c) // Convert IntStream to Stream<Character>
            .collect(Collectors.groupingBy(
                Function.identity(), 
                LinkedHashMap::new, 
                Collectors.counting()
            )) // Step 1: Create an ordered frequency map
            .entrySet().stream()
            .filter(entry -> entry.getValue() == 1L) // Step 2: Keep only uniques
            .map(Map.Entry::getKey)
            .reduce((first, second) -> second) // Step 3: Get the last one
            .orElse(null);

        System.out.println("Last non-repeating character: " + result);
    }
}
2. The Optimized "One-Liner" ExplainedIf an interviewer asks how to optimize this, you can explain that the logic remains $O(n)$ because we must read the whole string to know if the very first character repeats later on.Line-by-Line Breakdown:input.chars(): Converts the String into an IntStream. Computers see characters as numbers (e.g., 'A' is 65)..mapToObj(c -> (char) c): We wrap those numbers into Character objects so we can use them in a Map..collect(groupingBy(...)):Function.identity(): The character itself is the "Key".LinkedHashMap::new: This is critical. A normal HashMap is like a bucket where items get scrambled. A LinkedHashMap is like a line (queue); it remembers that 'J' came before 'a'.Collectors.counting(): This is the "Value". It increments a counter every time it sees the same key..entrySet().stream(): We take our finished map and turn it back into a stream of pairs (Key + Count)..filter(entry -> entry.getValue() == 1L): We throw away any character that has a count higher than 1..reduce((first, second) -> second):Imagine the unique characters are [v, S, t, r, e, m].It takes v and S, keeps S.It takes S and t, keeps t.It continues until only m (the last one) remains.

2. Given a sentence, find the word that has the highest length
String str = "I am learning Java Streams API";
String ans = Arrays.stream(str.split(" ")).max(Comparator.comparing(String::length)).get();
S.O.P(ans)

3. Remove duplicates from the string and return in the same ordeString str = "dabsadefg";
String str = "dabsadefg";
str.chars().distinct().mapToObj(c->(char)c).forEach(System.out::print);
or
Arrays.stream(str.split("")).distinct().forEach(System.out::print);

4.  Find the word that has the second highest length
String str = "I am learning Java Streams API";
String ans = Arrays.stream(str.split(" "))
				   .sorted(Comparator.comparing(String::length).reversed())
				   .skip(1).findFirst().get();
				 
5. Find the 2nd highest length word in the given sentence
String str = "I am learning Java Streams API";
int ans = Arrays.stream(str.split(" "))
				.map(x->x.length())
				.sorted(Comparator.reverseOrder())
				.skip(1)
				.findFirst()
				.get();
S.O.P(ans);

6. Given a sentence, find the occurrence of each word
String str = "I am learning Streams API in JAVA JAVA";
Map<String, Long> map = Arrays.stream(str.split(" "))
						  .collect(Collectors.groupingBy(x->x, Collectors.counting()));
S.O.P(map);

7. Given a sentence, find the words with a specified number of vowels
String str = "I am learning Streams API in JAVA";
Arrays.stream(str.split(" ")).filter(x->x.replaceAll([^aeiouAEIOU],"").length()==2).forEach(System.out::println);
						  
8. Divide given integer list into lists of even and odd numbers
int arr[] = {1,2,3,4,5,6,7,8};
List<Integer> list = Arrays.stream(arr).boxed().collect(Collectors.toList());
List<List<Integer>> checkedList = list.stream().collect(Collectors.groupingBy(x->x%2==0, 				Collectors.toList()))
.entrySet()
.map(x->x.getValue())
.collect(Collectors.toList());

//boxed is used to convert integer primitive to List<Integer>
// instead of Collectors.groupingBy you can also use Collectors.partitioningBy

9. Given a word, find the occurrence of each character
String str = "Mississippi";
Map<Character, Long> result = str.chars().mapToObj(c -> (char)c)
											.collect(Collectors.groupingBy(c->c, 
											Collectors.counting()));
											
10. Arrange the numbers in Descending/Ascending
int[] arr = {1,2,3,4,5};
output: 54321/ 12345
Arrays.stream(arr).mapToObj(x->x).sorted().forEach(System.out::print);
Arrays.stream(arr).mapToObj(x->x).sorted(Comparator.reverseOrder()).forEach(System.out::print);

11. Given an array, find the sum of unique elements
int[] arr = {1,6,7,8,1,1,8,8,7};
int result = Arrays.stream(arr).distinct().sum();
S.O.P(result);
				
12. Given a string, find the first non-repeated character
String str = "Hello World";

Optional<Character> ch = str.chars().mapToObj(c -> (char) c).collect(Collectors.groupingBy(Function.identity, LinkedHashMap::new,Collectors.counting())).entrySet().stream().filter(x->x.getValue() == 1L).map(Map.Entry :: getKey).findFirst();
ch.ifPresent(System.out::print);

or

String result  = Arrays.stream(str.split("")).filter(c-> str.indexOf(c) == str.lastIndexOf(c)).findFirst().get();
S.O.P(result);

13. Given a string, find the first repeated character
String str = "Hello World";
char ch = str.chars().mapToObj(c-> (char) c).collect(Collectors.groupingBy(c-> c, LinkedHashMap::new, Collectors.counting())).entrySet().stream().filter(x-> x.getValue() > 1L).map(Map.Entry::getKey).findFirst().get();

Or 
String result  = Arrays.stream(str.split("")).filter(c-> str.indexOf(c) != str.lastIndexOf(c)).findFirst().get();
S.O.P(result);

14. Given an array of integers, group the numbers by the range 
	int[] arr = {2,3,10,14,20,24,30,34,40,44,50,54};
0–9   → [2, 3]
10–19 → [10, 14]
20–29 → [20, 24]
30–39 → [30, 34]
40–49 → [40, 44]
50–59 → [50, 54]

Map<Integer, List<Integer>> result = Arrays.stream(arr).boxed().collect(Collectors.groupingBy(x->x/10*10,LinkedHashMap::new, Collectors.toList()));
S.O.P(result);

15.Given a list of strings, create a list that contains only integers
String[] str = {"abc","123","456","xyz"}

Arrays.stream(str).filter(x->x.matches("\\d+")).map(Integer::valueOf).collect(Collectors.toList()).forEach(System.out::println);

16. Find the products of the first two elements in an array
int[] arr = {12,5,6,9,2,4};

int result = Arrays.stream(arr).limit(2).reduce(1,(a,b)->a*b);
S.O.P(result);

17. Group /Pair anagrams from a list of Strings.
String[] s = {"pat","tap","pan","nap","Team","meat","tree"};

List<String> list = Arrays.stream(s).collect(Collectors.toList());
Collection<List<String>> result = list.stream().collect(Collectors.groupingBy(Arrays.stream(word -> word.toLowerCase().split("")).sorted().collect(Collectors.joining()))).values();

18. Write a stream program to multiply alternative numbers in an array
int[] arr = {4,5,1,7,2,9,2};
int result = IntStream.range(0,arr.length).filter(x->x%2 == 0).map(x->arr[x]).reduce(1, (a,b) -> a*b);

19. Write a program to multiply 1st and last element, 2nd and 2nd last element etc
int[] arr = {4,5,1,2,9,2};
int result = Integer.range(0, arr.length/2).map(x-> arr[x]*arr[arr.length-x-1]).forEach(System.out::println);

20. Write a stream program to move all zero’s to beginning of array
int[] arr = {5,0,1,0,8,0};
List<Integer> result = Arrays.stream(arr).boxed().collect(Collectors.partitioningBy(x->x!=0)).values().stream().flatMap(x->x.stream()).collect(Collectors.toList());

or 

List<Integer> nonZeros = Arrays.stream(arr)
        .filter(x -> x != 0)
        .boxed()
        .collect(Collectors.toList());

List<Integer> zeros = Arrays.stream(arr)
        .filter(x -> x == 0)
        .boxed()
        .collect(Collectors.toList());

nonZeros.addAll(zeros);
“partitioningBy returns a map, so relying on values() order is unsafe; sorting or filtering is better for predictable results.”

21.  In a given array of integers, return true if it contains distinct values
int[] arr = {5,0,1,0,8,0};
Arrays.stream(arr).boxed().collect(Collectors.groupingBy(x->x, Collectors.counting())).values().stream().noneMatch(x->x>1);
or 
boolean allUnique =
    Arrays.stream(arr)
          .distinct()
          .count() == arr.length;


