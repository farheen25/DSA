Creational Design Patterns kya hote hain?
Ye design patterns object creation process ko control karte hain, taki code flexible aur reusable ho.
Simple shabdon me – "kaun, kab aur kaise object banayega" – iska control aapke paas hota hai.

🛠 Types of Creational Design Patterns (emoji ke saath)
Singleton Pattern 🏠

Concept: Poore system me kisi class ka sirf ek hi object hona chahiye.

Example: Colony ka ek hi paani ka tank 🚰 – sab waha se paani lete hain.

Benefit: Memory bachta hai aur centralized control milta hai.

Factory Method Pattern 🏭

Concept: Object creation ki responsibility ek factory class ko do, taki client ko exact class ka pata na ho.

Example: Pizza shop 🍕 – aap sirf "Veg" ya "Cheese Burst" bolte ho, kitchen decide karta hai kaunsa pizza class banani hai.

Benefit: Naye product types easily add ho sakte hain bina client code change kiye.

Abstract Factory Pattern 🏢

Concept: Related objects ka poora family banane ke liye factory of factories ka use.

Example: iPhone factory 📱 vs Samsung factory 📱 – dono phone, charger, earphones banate hain but apne-apne style me.

Benefit: Pura product family easily switch kar sakte ho.

Builder Pattern 🧱

Concept: Complex object ko step-by-step build karna.

Example: Subway sandwich 🥪 – pehle bread, fir vegetables, fir sauce, fir cheese… har step customize hota hai.

Benefit: Object banate waqt zyada flexibility milti hai.

Prototype Pattern 🐑

Concept: Existing object ka clone banake use karna instead of new object creation har bar.

Example: Photocopy machine 📄 – ek original document se multiple copies ban jati hain bina dobara likhe.

Benefit: Time aur performance dono bachaata hai.

📌 Summary Table
Pattern	Emoji	Real-life Example
Singleton	🏠	Colony ka 1 paani tank
Factory Method	🏭	Pizza shop 🍕
Abstract Factory	🏢	iPhone vs Samsung Factory 📱
Builder	🧱	Subway Sandwich 🥪
Prototype	🐑	Photocopy Machine 📄


---- example for singleton class
// Singleton Class
public class WaterTank {

    private static WaterTank filled; // Lazy initialization (null initially)

    private WaterTank() {
        System.out.println("Paani ka tank ban gaya! 🏠🚰");
    }

    public static WaterTank fillWater() {
        if (filled == null) { // Object tabhi banega jab pehli baar call hoga
            filled = new WaterTank();
        }
        return filled;
    }

    public void supplyWater() {
        System.out.println("Water used by resident... 💧");
    }

    public static void main(String[] args) {
        WaterTank user1 = WaterTank.fillWater();
        user1.supplyWater();

        WaterTank user2 = WaterTank.fillWater();
        user2.supplyWater();

        System.out.println("Dono resident ne same water tank se pani bhara? " + (user1 == user2));
    }
}



Note:
Eager Initialization vs Lazy Initialization
Eager initialization: Agar tum object yahi pe create kar dete ho:

private static WaterTank filled = new WaterTank(); 
To class load hote hi tank ban jayega, chahe use ho ya na ho.

Lazy initialization: Tum abhi jaise kar rahe ho:

private static WaterTank filled;
Aur object tabhi create hota hai jab pehli baar fillWater() call hota hai

--------------------
Factory Pattern
Analogy: Car Manufacturing Factory 🚗

Socho tum ek car buyer ho. Tum showroom me jaake kehte ho,

“Mujhe ek SUV chahiye”
ya
“Mujhe ek Sedan chahiye”

Tum showroom me khud engine, chassis, seats, tyres laga ke car assemble nahi karte.
Instead, factory ke andar ek process hai jo tumhare requirement ke hisaab se car bana ke deta hai.

Tum bas request karte ho type of car ka.

Factory decide karti hai kaunsa model, kaunsa part use hoga, kaise assemble hoga.

Tumhe ready-made product mil jata hai, aur tumhe creation ka detail pata bhi nahi hota.

Programming me kaise match hota hai:

Showroom → Factory class

Customer → Client code

SUV, Sedan → Different subclasses (Car types)

Assembling process → Object creation logic

Client code bas “mujhe SUV chahiye” bolta hai (method call karta hai),
factory poora creation ka headache handle karke final object return kar deta hai.

Isliye is pattern ka motto hota hai:

"Don’t call new directly — let the factory build it for you."

Step 1: Common Interface (Car)

public interface Car {
    void assemble();
}

Step 2: Different Car Types

public class SUV implements Car {
    @Override
    public void assemble() {
        System.out.println("Assembling an SUV with off-road features 🚙");
    }
}

public class Sedan implements Car {
    @Override
    public void assemble() {
        System.out.println("Assembling a Sedan with luxury features 🚗");
    }
}

public class Hatchback implements Car {
    @Override
    public void assemble() {
        System.out.println("Assembling a Hatchback with compact design 🚘");
    }
}

Step 3: Car Factory

public class CarFactory {
    public Car createCar(String type) {
        if (type == null || type.isEmpty()) {
            return null;
        }
        switch (type.toUpperCase()) {
            case "SUV":
                return new SUV();
            case "SEDAN":
                return new Sedan();
            case "HATCHBACK":
                return new Hatchback();
            default:
                throw new IllegalArgumentException("Unknown car type: " + type);
        }
    }
}

Step 4: Client Code

public class Main {
    public static void main(String[] args) {
        CarFactory factory = new CarFactory();

        Car car1 = factory.createCar("SUV");
        car1.assemble();

        Car car2 = factory.createCar("SEDAN");
        car2.assemble();

        Car car3 = factory.createCar("HATCHBACK");
        car3.assemble();
    }
}


Assembling an SUV with off-road features 🚙
Assembling a Sedan with luxury features 🚗
Assembling a Hatchback with compact design 🚘

--------------------------------------------------------
Abstract Factory: UIFactory (methods: createButton(), createTextbox())

Concrete Factories: WindowsFactory, MacFactory (apne platform ke components banate hain)

Abstract Products: Button, Textbox (interfaces)

Concrete Products: WindowsButton, MacButton, WindowsTextbox, MacTextbox

// Abstract Products
interface Button {
    void paint();
}

interface Textbox {
    void render();
}

// Concrete Products for Windows
class WindowsButton implements Button {
    public void paint() {
        System.out.println("Rendering Windows style Button");
    }
}

class WindowsTextbox implements Textbox {
    public void render() {
        System.out.println("Rendering Windows style Textbox");
    }
}

// Concrete Products for Mac
class MacButton implements Button {
    public void paint() {
        System.out.println("Rendering Mac style Button");
    }
}

class MacTextbox implements Textbox {
    public void render() {
        System.out.println("Rendering Mac style Textbox");
    }
}

// Abstract Factory
interface UIFactory {
    Button createButton();
    Textbox createTextbox();
}

// Concrete Factory for Windows
class WindowsFactory implements UIFactory {
    public Button createButton() {
        return new WindowsButton();
    }
    public Textbox createTextbox() {
        return new WindowsTextbox();
    }
}

// Concrete Factory for Mac
class MacFactory implements UIFactory {
    public Button createButton() {
        return new MacButton();
    }
    public Textbox createTextbox() {
        return new MacTextbox();
    }
}

// Client code
public class Application {
    private Button button;
    private Textbox textbox;

    public Application(UIFactory factory) {
        button = factory.createButton();
        textbox = factory.createTextbox();
    }

    public void renderUI() {
        button.paint();
        textbox.render();
    }

    public static void main(String[] args) {
        UIFactory factory;

        // Let's say we detect the OS dynamically here (hardcoded for demo)
        String osName = "Windows"; // change to "Mac" to test Mac UI

        if (osName.equals("Windows")) {
            factory = new WindowsFactory();
        } else {
            factory = new MacFactory();
        }

        Application app = new Application(factory);
        app.renderUI();
    }
}

| Pattern     | Type       | Purpose                              | Real Life Example                        |
| ----------- | ---------- | ------------------------------------ | ---------------------------------------- |
| **Builder** | Creational | Step-by-step complex object creation | Pizza customization, `StringBuilder`     |
| **Adapter** | Structural | Bridge between incompatible classes  | Mobile charger plug adapter, JDBC driver |

Builder pattern ek creational design pattern hai jo complex objects ko step-by-step construct karne ka tarika deta hai.
Ye pattern construction process ko object ke representation se separate karta hai.

public class StringBuilderExample {
    public static void main(String[] args) {
        // StringBuilder object banaya
        StringBuilder sb = new StringBuilder();

        // Step by step string build karna
        sb.append("Hello");
        sb.append(" ");
        sb.append("World");
        sb.append("!");
        
        // Final result
        System.out.println(sb.toString());
    }
}

Adapter pattern example:
Suppose you have two buddies, one of them speaks French exclusively and the other English exclusively. The language barrier prevents them from communicating the way you want them to.

Target (Interface) → EnglishSpeaker (jo client use karega)

Adaptee → FrenchSpeaker (jo sirf French bolta hai)

Adapter → FrenchToEnglishAdapter (jo French ko English me translate karke connect karega)

// Target Interface
interface EnglishSpeaker {
    void speakEnglish(String words);
}

// Adaptee (French speaker)
class FrenchSpeaker {
    void parlerFrancais(String mots) {
        System.out.println("Parle en Français: " + mots);
    }
}

// Adapter (bridge between French and English)
class FrenchToEnglishAdapter implements EnglishSpeaker {
    private FrenchSpeaker frenchSpeaker;

    public FrenchToEnglishAdapter(FrenchSpeaker frenchSpeaker) {
        this.frenchSpeaker = frenchSpeaker;
    }

    @Override
    public void speakEnglish(String words) {
        // Adapter logic: English → French
        System.out.println("Translating English to French...");
        frenchSpeaker.parlerFrancais(words);
    }
}

// Client code
public class AdapterPatternDemo {
    public static void main(String[] args) {
        // Adaptee object
        FrenchSpeaker frenchGuy = new FrenchSpeaker();

        // Adapter wrapping the French speaker
        EnglishSpeaker adapter = new FrenchToEnglishAdapter(frenchGuy);

        // Client speaks in English, adapter translates
        adapter.speakEnglish("Hello Friend!");
    }
}

📌 Proxy Design Pattern – Notes

Definition:
A structural design pattern that provides a surrogate (stand-in) object which controls access to another object (the real subject).

🔑 Key Points

Acts as a middle layer between client and real object.

Used for access control, lazy initialization, logging, caching, remote access.

Follows the same interface as the real object.

Types of Proxy:

Virtual Proxy → loads heavy objects lazily (e.g., images).

Protection Proxy → controls access (e.g., role-based access).

Remote Proxy → represents an object in a different address space (e.g., RMI).

Caching Proxy → returns cached results to improve performance.

🏦 Real-World Examples

ATM → Bank server (ATM is the proxy).

Credit card → Bank account.

Browser caching images or pages.

✅ Structure

Subject (Interface) → common contract.

RealSubject → the actual object with core logic.

Proxy → controls access to RealSubject.

Client → uses Subject interface, unaware of Proxy/RealSubject difference.

⚡ Advantages

Adds security, logging, performance optimization.

Client code stays simple & decoupled.

⚠ Disadvantages

Extra layer → slight performance overhead.

Increases complexity.

👉 One-liner:
Proxy is a design pattern that provides a substitute object to control, enhance, or restrict access to the real object.

Example
// Online Java Compiler
// Use this editor to write, compile and run your Java code online

interface BankAccount {
    void withDraw(String ac, double amount);
}

class RealAccount implements BankAccount {
    @Override
    public void withDraw(String ac, double amount) {
        System.out.println("Withdrawing " + amount + " from account: " + ac);
    }
}

class ProxyAccount implements BankAccount {
    private RealAccount realAccount;
    private String role;
    
    ProxyAccount(String role){
        this.role = role;
        realAccount = new RealAccount();
    }
    
    @Override
    public void withDraw(String ac, double amount) {
        if(role == "ADMIN")
        {
           realAccount.withDraw(ac, amount); 
        }
        else {
            System.out.println("role is not permitted");
        }
    }
}
class Main {
    public static void main(String[] args) {
       BankAccount ba = new ProxyAccount("ADMIN");
       ba.withDraw("1234",5000);
       BankAccount ba1 = new ProxyAccount("USER");
       ba1.withDraw("1234",50000);
    }
}
----------------
Decorator design pattern:
Decorator Design Pattern – Short Notes

Type: Structural Design Pattern

Definition: Attaches additional responsibilities to an object dynamically.
Open/Closed Principle Recap

Open for extension → You can extend an object’s behavior.

Closed for modification → You don’t need to change the existing class code.

Analogy: Wrapping a gift box – each wrapper adds something new without changing the original gift.

Key Components

Component → Interface/abstract class defining behavior.

Concrete Component → Base object with default behavior.

Decorator (abstract) → Holds reference to a component, implements the same interface.

Concrete Decorators → Extend functionality by overriding methods.

Advantages

Adds behavior at runtime (flexible than inheritance).

Promotes open/closed principle (open for extension, closed for modification).

Avoids class explosion caused by multiple subclasses.

Disadvantages

Can result in many small classes.

Debugging can be harder due to multiple layers of wrapping.

Example

Coffee Shop: SimpleCoffee + decorators like Milk, Sugar, WhippedCream.

Java I/O Streams: BufferedInputStream(new FileInputStream("file.txt")).

👉 Use when: You need to add/remove features dynamically without altering the base class.

Example:
// Online Java Compiler
// Use this editor to write, compile and run your Java code online

interface Coffee {
    String getDescription();
    double getCost();
}

class PlainCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Simple Coffee";
    }
    
    @Override
    public double getCost() {
        return 5.0;
    }
}

abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;
    CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
    
    public String getDescription() {
        return coffee.getDescription();
    }
    
    public double getCost() {
        return coffee.getCost();
    }
}

class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    public String getDescription() {
        return coffee.getDescription() + ", Milk";
    }
    
    public double getCost() {
        return coffee.getCost() + 1.5;
    }
}

class WhippedCreamDecorator extends CoffeeDecorator {
    public WhippedCreamDecorator(Coffee coffee) {
        super(coffee);
    }
    
    public String getDescription() {
        return coffee.getDescription() + ", Cream";
    }
    
    public double getCost() {
        return coffee.getCost() + 1;
    }
}

class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    
    public String getDescription() {
        return coffee.getDescription() + ", Sugar";
    }
    
    public double getCost() {
        return coffee.getCost() + 1;
    }
}


class Main {
    public static void main(String[] args) {
      Coffee coffee = new PlainCoffee();
      coffee = new MilkDecorator(coffee);
      System.out.println(coffee.getDescription() + " -> $" + coffee.getCost());
      coffee = new SugarDecorator(coffee);
      System.out.println(coffee.getDescription() + " -> $" + coffee.getCost());
      coffee = new WhippedCreamDecorator(coffee);
      System.out.println(coffee.getDescription() + " -> $" + coffee.getCost());
    }
}

------------------
Facade Design Pattern – Short Notes

Type: Structural Design Pattern

Definition: Provides a unified, simplified interface to a set of complex subsystems.

Analogy: Universal remote control – hides the complexity of multiple devices.

Key Points

Hides subsystem complexity from clients.

Client interacts with one facade object instead of multiple subsystem classes.

Subsystems remain unchanged; facade only orchestrates calls.

Promotes loose coupling between client and subsystems.

SOLID Principles

SRP: Facade has one job → simplify subsystem usage.

DIP: Client depends on Facade (abstraction), not on subsystem details.

Advantages

Simplifies client code.

Reduces dependency between client and subsystems.

Makes the system easier to use.

Disadvantages

Can become a god object if it grows too much.

May hide too much flexibility of subsystems.

Real-Time Examples

Home Theater System: watchMovie() hides projector, DVD, sound setup.

Banking App: transferMoney() hides authentication, debit/credit, logging, notifications.

Java Libraries:

javax.faces.context.FacesContext (JSF)

java.net.URL (hides sockets, protocols, DNS handling)

Spring’s JdbcTemplate (hides JDBC boilerplate).

👉 In short: Facade makes complex things simple for the client without changing the subsystems.

Example
// Subsystem classes
class AuthenticationService {
    public boolean authenticate(String userId, String password) {
        System.out.println("Authenticating user: " + userId);
        return true; // assume always valid
    }
}

class AccountService {
    public boolean checkBalance(String accountId, double amount) {
        System.out.println("Checking balance for " + accountId);
        return true;
    }

    public void debit(String accountId, double amount) {
        System.out.println("Debiting " + amount + " from " + accountId);
    }

    public void credit(String accountId, double amount) {
        System.out.println("Crediting " + amount + " to " + accountId);
    }
}

class TransactionLogger {
    public void log(String message) {
        System.out.println("Transaction Log: " + message);
    }
}

class NotificationService {
    public void notifyUser(String userId, String message) {
        System.out.println("Notifying " + userId + ": " + message);
    }
}

// Facade
class BankingFacade {
    private AuthenticationService authService;
    private AccountService accountService;
    private TransactionLogger logger;
    private NotificationService notifier;

    public BankingFacade() {
        this.authService = new AuthenticationService();
        this.accountService = new AccountService();
        this.logger = new TransactionLogger();
        this.notifier = new NotificationService();
    }

    public void transferMoney(String userId, String password, 
                              String fromAcc, String toAcc, double amount) {
        if (authService.authenticate(userId, password) 
            && accountService.checkBalance(fromAcc, amount)) {
            
            accountService.debit(fromAcc, amount);
            accountService.credit(toAcc, amount);
            logger.log("Transfer of " + amount + " from " + fromAcc + " to " + toAcc);
            notifier.notifyUser(userId, "Transfer Successful: " + amount);
        } else {
            System.out.println("Transfer failed!");
        }
    }
}

public class FacadeBankingDemo {
    public static void main(String[] args) {
        BankingFacade bankingFacade = new BankingFacade();
        bankingFacade.transferMoney("user123", "password", "ACC1001", "ACC2002", 500.0);
    }
}
-------------
blueprint for adapter design pattern
// 1. Target interface (expected by client)
interface Target {
    void request();
}

// 2. Adaptee (legacy / incompatible class)
class Adaptee {
    public void specificRequest() {
        System.out.println("Called specificRequest() from Adaptee");
    }
}

// 3. Adapter (makes Adaptee compatible with Target)
class Adapter implements Target {
    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        // Translate request into Adaptee's method
        adaptee.specificRequest();
    }
}

// 4. Client (uses Target interface)
public class AdapterPatternDemo {
    public static void main(String[] args) {
        Adaptee adaptee = new Adaptee();
        
        // Wrap adaptee in an adapter
        Target target = new Adapter(adaptee);
        
        // Client uses Target interface
        target.request();
    }
}

-----------------
blue print for proxy design pattern
// 1. Subject (common interface)
interface Subject {
    void request();
}

// 2. RealSubject (actual implementation)
class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("RealSubject: Handling the request.");
    }
}

// 3. Proxy (controls access to RealSubject)
class Proxy implements Subject {
    private RealSubject realSubject;

    @Override
    public void request() {
        if (realSubject == null) {
            realSubject = new RealSubject(); // Lazy initialization
        }

        System.out.println("Proxy: Performing access control or logging before delegating.");
        realSubject.request();
    }
}

// 4. Client
public class ProxyPatternDemo {
    public static void main(String[] args) {
        Subject proxy = new Proxy();

        // Client calls proxy instead of directly using RealSubject
        proxy.request();
    }
}
----------------
blueprint for facade design pattern
// 1. Subsystem classes
class SubsystemA {
    void operationA() {
        System.out.println("SubsystemA: operationA executed");
    }
}

class SubsystemB {
    void operationB() {
        System.out.println("SubsystemB: operationB executed");
    }
}

class SubsystemC {
    void operationC() {
        System.out.println("SubsystemC: operationC executed");
    }
}

// 2. Facade (simplifies subsystem usage)
class Facade {
    private SubsystemA subsystemA;
    private SubsystemB subsystemB;
    private SubsystemC subsystemC;

    public Facade() {
        this.subsystemA = new SubsystemA();
        this.subsystemB = new SubsystemB();
        this.subsystemC = new SubsystemC();
    }

    // Unified method that hides complexity
    public void simpleOperation() {
        System.out.println("Facade: Coordinating subsystems...");
        subsystemA.operationA();
        subsystemB.operationB();
        subsystemC.operationC();
    }
}

// 3. Client
public class FacadePatternDemo {
    public static void main(String[] args) {
        Facade facade = new Facade();
        
        // Client calls only the Facade method
        facade.simpleOperation();
    }
}

-----------------
blueprint for decorator design pattern
// 1. Component
interface Component {
    void operation();
}

// 2. Concrete Component
class ConcreteComponent implements Component {
    @Override
    public void operation() {
        System.out.println("ConcreteComponent: Base operation");
    }
}

// 3. Decorator (abstract class)
abstract class Decorator implements Component {
    protected Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    @Override
    public void operation() {
        component.operation(); // delegate to wrapped object
    }
}

// 4. Concrete Decorators
class ConcreteDecoratorA extends Decorator {
    public ConcreteDecoratorA(Component component) {
        super(component);
    }

    @Override
    public void operation() {
        super.operation(); // call base behavior
        System.out.println("ConcreteDecoratorA: Added behavior A");
    }
}

class ConcreteDecoratorB extends Decorator {
    public ConcreteDecoratorB(Component component) {
        super(component);
    }

    @Override
    public void operation() {
        super.operation(); // call base behavior
        System.out.println("ConcreteDecoratorB: Added behavior B");
    }
}

// 5. Client
public class DecoratorPatternDemo {
    public static void main(String[] args) {
        Component component = new ConcreteComponent();

        // Wrap with DecoratorA
        Component decoratedA = new ConcreteDecoratorA(component);

        // Wrap with DecoratorB on top of DecoratorA
        Component decoratedB = new ConcreteDecoratorB(decoratedA);

        // Call operation
        decoratedB.operation();
    }
}
----
Observer design pattern ek behavioral design pattern hai jo one-to-many dependency establish karta hai. Matlab agar ek object (Subject) ka state change hota hai, toh usse related huye saare objects (Observers) automatically update ho jaate hain.

Real life Example:

👉 WhatsApp Group

Ek group admin (Subject) jab ek message bhejta hai, toh saare group members (Observers) ko turant notification milta hai.

Agar koi member group chhod de, toh usse notifications milna band ho jaata hai.

Components of Observer Pattern:

Subject (Publisher)

Jo object observe kiya jaa raha hai.

Observers ko register/unregister karne ka kaam karta hai.

Jab bhi state change hoti hai, observers ko notify karta hai.

Observer (Subscriber)

Subject ke state change ko "observe" karta hai.

Jab bhi notification milti hai, apna kaam perform karta hai.

Concrete Subject

Actual implementation of Subject.

Concrete Observer

Actual implementation of Observer.

UML Flow:
Subject <---- Observer
   ↑              ↑
ConcreteSubject   ConcreteObserver

Java Example:
import java.util.*;

// Observer interface
interface Observer {
    void update(String message);
}

// Subject interface
interface Subject {
    void registerObserver(Observer o);
    void removeObserver(Observer o);
    void notifyObservers(String message);
}

// Concrete Subject
class YouTubeChannel implements Subject {
    private List<Observer> subscribers = new ArrayList<>();

    public void registerObserver(Observer o) {
        subscribers.add(o);
    }

    public void removeObserver(Observer o) {
        subscribers.remove(o);
    }

    public void notifyObservers(String message) {
        for (Observer o : subscribers) {
            o.update(message);
        }
    }

    // When new video uploaded
    public void uploadVideo(String title) {
        System.out.println("New Video Uploaded: " + title);
        notifyObservers("Check out new video: " + title);
    }
}

// Concrete Observer
class Subscriber implements Observer {
    private String name;

    Subscriber(String name) {
        this.name = name;
    }

    public void update(String message) {
        System.out.println(name + " got notification: " + message);
    }
}

// Test
public class ObserverPatternDemo {
    public static void main(String[] args) {
        YouTubeChannel channel = new YouTubeChannel();

        Observer user1 = new Subscriber("Ali");
        Observer user2 = new Subscriber("Sara");

        channel.registerObserver(user1);
        channel.registerObserver(user2);

        channel.uploadVideo("Observer Design Pattern Explained!");
    }
}

Output:
New Video Uploaded: Observer Design Pattern Explained!
Ali got notification: Check out new video: Observer Design Pattern Explained!
Sara got notification: Check out new video: Observer Design Pattern Explained!


✅ Key Point: Observer pattern loosely couples Publisher and Subscriber. Subject ko nahi pata hota ki observer kaise react karega, sirf notify kar deta hai.


Notes: Observer Design Pattern

Category: Behavioral Pattern

Intent: “Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified automatically.”

Use case: Jab ek object ka state change ho aur tumhe chahie ki automatically multiple objects ko update mile.

Real-life Examples:

YouTube channel (Subject) → Subscribers (Observers)

Stock Market (Subject) → Investors (Observers)

GUI Button (Subject) → Event Listeners (Observers)

Pros
✔ Loose coupling (Subject aur Observer ek interface ke through baat karte hain).
✔ Easy to add new observers.

Cons
✘ Order of notification guarantee nahi hota.
✘ Agar observers bahut heavy kaam karen to performance issue ho sakta hai.

SOLID Principle: Follows Open/Closed Principle and Dependency Inversion.

// Step 1: Observer interface
interface Observer {
    void update(String message);
}

// Step 2: Subject interface
interface Subject {
    void registerObserver(Observer o);
    void removeObserver(Observer o);
    void notifyObservers(String message);
}

// Step 3: Concrete Subject
class NewsChannel implements Subject {
    private List<Observer> observers = new ArrayList<>();

    public void registerObserver(Observer o) {
        observers.add(o);
    }

    public void removeObserver(Observer o) {
        observers.remove(o);
    }

    public void notifyObservers(String message) {
        for (Observer o : observers) {
            o.update(message);
        }
    }

    // Example: new news comes
    public void breakingNews(String news) {
        notifyObservers(news);
    }
}

// Step 4: Concrete Observers
class Subscriber implements Observer {
    private String name;

    public Subscriber(String name) {
        this.name = name;
    }

    public void update(String message) {
        System.out.println(name + " received news: " + message);
    }
}

// Step 5: Client
public class ObserverPatternDemo {
    public static void main(String[] args) {
        NewsChannel channel = new NewsChannel();

        Observer sub1 = new Subscriber("Farheen");
        Observer sub2 = new Subscriber("Aisha");

        channel.registerObserver(sub1);
        channel.registerObserver(sub2);

        channel.breakingNews("New Observer Pattern tutorial uploaded!");
    }
}

Notes: Strategy Design Pattern

Category: Behavioral Pattern

Intent: “Define a family of algorithms, encapsulate each one, and make them interchangeable at runtime.”

Use case: Jab ek kaam ke multiple tareeqe (algorithms) ho aur tum runtime pe decide karna chaho kaunsa use karna hai.

Real-life Examples:

Payment methods: Credit Card, PayPal, UPI

Travel modes: Car, Train, Plane

Sorting: QuickSort, MergeSort, BubbleSort

Java: Comparator in Collections framework

Pros
✔ Algorithms ko alag classes me encapsulate karna (clean code).
✔ Easily extendable → new algorithm add karna easy (Open/Closed Principle).
✔ Avoids if-else or switch clutter.

Cons
✘ Clients ko strategies ke differences samajhne hote hain.
✘ Zyada strategies banne pe number of classes badh jata hai.

SOLID Principle: Follows Open/Closed Principle & Dependency Inversion Principle.

// Step 1: Strategy interface
interface TravelStrategy {
    void travel(String source, String destination);
}

// Step 2: Concrete strategies
class CarTravel implements TravelStrategy {
    public void travel(String source, String destination) {
        System.out.println("Traveling from " + source + " to " + destination + " by Car.");
    }
}

class TrainTravel implements TravelStrategy {
    public void travel(String source, String destination) {
        System.out.println("Traveling from " + source + " to " + destination + " by Train.");
    }
}

class PlaneTravel implements TravelStrategy {
    public void travel(String source, String destination) {
        System.out.println("Traveling from " + source + " to " + destination + " by Plane.");
    }
}

// Step 3: Context
class TravelContext {
    private TravelStrategy strategy;

    public TravelContext(TravelStrategy strategy) {
        this.strategy = strategy;
    }

    public void startJourney(String source, String destination) {
        strategy.travel(source, destination);
    }
}

// Step 4: Client
public class StrategyTravelDemo {
    public static void main(String[] args) {
        TravelContext context;

        // User selects Car
        context = new TravelContext(new CarTravel());
        context.startJourney("Hyderabad", "Bangalore");

        // User selects Train
        context = new TravelContext(new TrainTravel());
        context.startJourney("Hyderabad", "Bangalore");

        // User selects Plane
        context = new TravelContext(new PlaneTravel());
        context.startJourney("Hyderabad", "Bangalore");
    }
}

