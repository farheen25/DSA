Creational Design Patterns kya hote hain?
Ye design patterns object creation process ko control karte hain, taki code flexible aur reusable ho.
Simple shabdon me – "kaun, kab aur kaise object banayega" – iska control aapke paas hota hai.

🛠 Types of Creational Design Patterns (emoji ke saath)
Singleton Pattern 🏠

Concept: Poore system me kisi class ka sirf ek hi object hona chahiye.

Example: Colony ka ek hi paani ka tank 🚰 – sab waha se paani lete hain.

Benefit: Memory bachta hai aur centralized control milta hai.

Factory Method Pattern 🏭

Concept: Object creation ki responsibility ek factory class ko do, taki client ko exact class ka pata na ho.

Example: Pizza shop 🍕 – aap sirf "Veg" ya "Cheese Burst" bolte ho, kitchen decide karta hai kaunsa pizza class banani hai.

Benefit: Naye product types easily add ho sakte hain bina client code change kiye.

Abstract Factory Pattern 🏢

Concept: Related objects ka poora family banane ke liye factory of factories ka use.

Example: iPhone factory 📱 vs Samsung factory 📱 – dono phone, charger, earphones banate hain but apne-apne style me.

Benefit: Pura product family easily switch kar sakte ho.

Builder Pattern 🧱

Concept: Complex object ko step-by-step build karna.

Example: Subway sandwich 🥪 – pehle bread, fir vegetables, fir sauce, fir cheese… har step customize hota hai.

Benefit: Object banate waqt zyada flexibility milti hai.

Prototype Pattern 🐑

Concept: Existing object ka clone banake use karna instead of new object creation har bar.

Example: Photocopy machine 📄 – ek original document se multiple copies ban jati hain bina dobara likhe.

Benefit: Time aur performance dono bachaata hai.

📌 Summary Table
Pattern	Emoji	Real-life Example
Singleton	🏠	Colony ka 1 paani tank
Factory Method	🏭	Pizza shop 🍕
Abstract Factory	🏢	iPhone vs Samsung Factory 📱
Builder	🧱	Subway Sandwich 🥪
Prototype	🐑	Photocopy Machine 📄


---- example for singleton class
// Singleton Class
public class WaterTank {

    private static WaterTank filled; // Lazy initialization (null initially)

    private WaterTank() {
        System.out.println("Paani ka tank ban gaya! 🏠🚰");
    }

    public static WaterTank fillWater() {
        if (filled == null) { // Object tabhi banega jab pehli baar call hoga
            filled = new WaterTank();
        }
        return filled;
    }

    public void supplyWater() {
        System.out.println("Water used by resident... 💧");
    }

    public static void main(String[] args) {
        WaterTank user1 = WaterTank.fillWater();
        user1.supplyWater();

        WaterTank user2 = WaterTank.fillWater();
        user2.supplyWater();

        System.out.println("Dono resident ne same water tank se pani bhara? " + (user1 == user2));
    }
}



Note:
Eager Initialization vs Lazy Initialization
Eager initialization: Agar tum object yahi pe create kar dete ho:

private static WaterTank filled = new WaterTank(); 
To class load hote hi tank ban jayega, chahe use ho ya na ho.

Lazy initialization: Tum abhi jaise kar rahe ho:

private static WaterTank filled;
Aur object tabhi create hota hai jab pehli baar fillWater() call hota hai

--------------------
Factory Pattern
Analogy: Car Manufacturing Factory 🚗

Socho tum ek car buyer ho. Tum showroom me jaake kehte ho,

“Mujhe ek SUV chahiye”
ya
“Mujhe ek Sedan chahiye”

Tum showroom me khud engine, chassis, seats, tyres laga ke car assemble nahi karte.
Instead, factory ke andar ek process hai jo tumhare requirement ke hisaab se car bana ke deta hai.

Tum bas request karte ho type of car ka.

Factory decide karti hai kaunsa model, kaunsa part use hoga, kaise assemble hoga.

Tumhe ready-made product mil jata hai, aur tumhe creation ka detail pata bhi nahi hota.

Programming me kaise match hota hai:

Showroom → Factory class

Customer → Client code

SUV, Sedan → Different subclasses (Car types)

Assembling process → Object creation logic

Client code bas “mujhe SUV chahiye” bolta hai (method call karta hai),
factory poora creation ka headache handle karke final object return kar deta hai.

Isliye is pattern ka motto hota hai:

"Don’t call new directly — let the factory build it for you."

Step 1: Common Interface (Car)

public interface Car {
    void assemble();
}

Step 2: Different Car Types

public class SUV implements Car {
    @Override
    public void assemble() {
        System.out.println("Assembling an SUV with off-road features 🚙");
    }
}

public class Sedan implements Car {
    @Override
    public void assemble() {
        System.out.println("Assembling a Sedan with luxury features 🚗");
    }
}

public class Hatchback implements Car {
    @Override
    public void assemble() {
        System.out.println("Assembling a Hatchback with compact design 🚘");
    }
}

Step 3: Car Factory

public class CarFactory {
    public Car createCar(String type) {
        if (type == null || type.isEmpty()) {
            return null;
        }
        switch (type.toUpperCase()) {
            case "SUV":
                return new SUV();
            case "SEDAN":
                return new Sedan();
            case "HATCHBACK":
                return new Hatchback();
            default:
                throw new IllegalArgumentException("Unknown car type: " + type);
        }
    }
}

Step 4: Client Code

public class Main {
    public static void main(String[] args) {
        CarFactory factory = new CarFactory();

        Car car1 = factory.createCar("SUV");
        car1.assemble();

        Car car2 = factory.createCar("SEDAN");
        car2.assemble();

        Car car3 = factory.createCar("HATCHBACK");
        car3.assemble();
    }
}


Assembling an SUV with off-road features 🚙
Assembling a Sedan with luxury features 🚗
Assembling a Hatchback with compact design 🚘

--------------------------------------------------------
Abstract Factory: UIFactory (methods: createButton(), createTextbox())

Concrete Factories: WindowsFactory, MacFactory (apne platform ke components banate hain)

Abstract Products: Button, Textbox (interfaces)

Concrete Products: WindowsButton, MacButton, WindowsTextbox, MacTextbox

// Abstract Products
interface Button {
    void paint();
}

interface Textbox {
    void render();
}

// Concrete Products for Windows
class WindowsButton implements Button {
    public void paint() {
        System.out.println("Rendering Windows style Button");
    }
}

class WindowsTextbox implements Textbox {
    public void render() {
        System.out.println("Rendering Windows style Textbox");
    }
}

// Concrete Products for Mac
class MacButton implements Button {
    public void paint() {
        System.out.println("Rendering Mac style Button");
    }
}

class MacTextbox implements Textbox {
    public void render() {
        System.out.println("Rendering Mac style Textbox");
    }
}

// Abstract Factory
interface UIFactory {
    Button createButton();
    Textbox createTextbox();
}

// Concrete Factory for Windows
class WindowsFactory implements UIFactory {
    public Button createButton() {
        return new WindowsButton();
    }
    public Textbox createTextbox() {
        return new WindowsTextbox();
    }
}

// Concrete Factory for Mac
class MacFactory implements UIFactory {
    public Button createButton() {
        return new MacButton();
    }
    public Textbox createTextbox() {
        return new MacTextbox();
    }
}

// Client code
public class Application {
    private Button button;
    private Textbox textbox;

    public Application(UIFactory factory) {
        button = factory.createButton();
        textbox = factory.createTextbox();
    }

    public void renderUI() {
        button.paint();
        textbox.render();
    }

    public static void main(String[] args) {
        UIFactory factory;

        // Let's say we detect the OS dynamically here (hardcoded for demo)
        String osName = "Windows"; // change to "Mac" to test Mac UI

        if (osName.equals("Windows")) {
            factory = new WindowsFactory();
        } else {
            factory = new MacFactory();
        }

        Application app = new Application(factory);
        app.renderUI();
    }
}
