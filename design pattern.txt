Creational Design Patterns kya hote hain?
Ye design patterns object creation process ko control karte hain, taki code flexible aur reusable ho.
Simple shabdon me â€“ "kaun, kab aur kaise object banayega" â€“ iska control aapke paas hota hai.

ğŸ›  Types of Creational Design Patterns (emoji ke saath)
Singleton Pattern ğŸ 

Concept: Poore system me kisi class ka sirf ek hi object hona chahiye.

Example: Colony ka ek hi paani ka tank ğŸš° â€“ sab waha se paani lete hain.

Benefit: Memory bachta hai aur centralized control milta hai.

Factory Method Pattern ğŸ­

Concept: Object creation ki responsibility ek factory class ko do, taki client ko exact class ka pata na ho.

Example: Pizza shop ğŸ• â€“ aap sirf "Veg" ya "Cheese Burst" bolte ho, kitchen decide karta hai kaunsa pizza class banani hai.

Benefit: Naye product types easily add ho sakte hain bina client code change kiye.

Abstract Factory Pattern ğŸ¢

Concept: Related objects ka poora family banane ke liye factory of factories ka use.

Example: iPhone factory ğŸ“± vs Samsung factory ğŸ“± â€“ dono phone, charger, earphones banate hain but apne-apne style me.

Benefit: Pura product family easily switch kar sakte ho.

Builder Pattern ğŸ§±

Concept: Complex object ko step-by-step build karna.

Example: Subway sandwich ğŸ¥ª â€“ pehle bread, fir vegetables, fir sauce, fir cheeseâ€¦ har step customize hota hai.

Benefit: Object banate waqt zyada flexibility milti hai.

Prototype Pattern ğŸ‘

Concept: Existing object ka clone banake use karna instead of new object creation har bar.

Example: Photocopy machine ğŸ“„ â€“ ek original document se multiple copies ban jati hain bina dobara likhe.

Benefit: Time aur performance dono bachaata hai.

ğŸ“Œ Summary Table
Pattern	Emoji	Real-life Example
Singleton	ğŸ 	Colony ka 1 paani tank
Factory Method	ğŸ­	Pizza shop ğŸ•
Abstract Factory	ğŸ¢	iPhone vs Samsung Factory ğŸ“±
Builder	ğŸ§±	Subway Sandwich ğŸ¥ª
Prototype	ğŸ‘	Photocopy Machine ğŸ“„


---- example for singleton class
// Singleton Class
public class WaterTank {

    private static WaterTank filled; // Lazy initialization (null initially)

    private WaterTank() {
        System.out.println("Paani ka tank ban gaya! ğŸ ğŸš°");
    }

    public static WaterTank fillWater() {
        if (filled == null) { // Object tabhi banega jab pehli baar call hoga
            filled = new WaterTank();
        }
        return filled;
    }

    public void supplyWater() {
        System.out.println("Water used by resident... ğŸ’§");
    }

    public static void main(String[] args) {
        WaterTank user1 = WaterTank.fillWater();
        user1.supplyWater();

        WaterTank user2 = WaterTank.fillWater();
        user2.supplyWater();

        System.out.println("Dono resident ne same water tank se pani bhara? " + (user1 == user2));
    }
}



Note:
Eager Initialization vs Lazy Initialization
Eager initialization: Agar tum object yahi pe create kar dete ho:

private static WaterTank filled = new WaterTank(); 
To class load hote hi tank ban jayega, chahe use ho ya na ho.

Lazy initialization: Tum abhi jaise kar rahe ho:

private static WaterTank filled;
Aur object tabhi create hota hai jab pehli baar fillWater() call hota hai

--------------------
Factory Pattern
Analogy: Car Manufacturing Factory ğŸš—

Socho tum ek car buyer ho. Tum showroom me jaake kehte ho,

â€œMujhe ek SUV chahiyeâ€
ya
â€œMujhe ek Sedan chahiyeâ€

Tum showroom me khud engine, chassis, seats, tyres laga ke car assemble nahi karte.
Instead, factory ke andar ek process hai jo tumhare requirement ke hisaab se car bana ke deta hai.

Tum bas request karte ho type of car ka.

Factory decide karti hai kaunsa model, kaunsa part use hoga, kaise assemble hoga.

Tumhe ready-made product mil jata hai, aur tumhe creation ka detail pata bhi nahi hota.

Programming me kaise match hota hai:

Showroom â†’ Factory class

Customer â†’ Client code

SUV, Sedan â†’ Different subclasses (Car types)

Assembling process â†’ Object creation logic

Client code bas â€œmujhe SUV chahiyeâ€ bolta hai (method call karta hai),
factory poora creation ka headache handle karke final object return kar deta hai.

Isliye is pattern ka motto hota hai:

"Donâ€™t call new directly â€” let the factory build it for you."

Step 1: Common Interface (Car)

public interface Car {
    void assemble();
}

Step 2: Different Car Types

public class SUV implements Car {
    @Override
    public void assemble() {
        System.out.println("Assembling an SUV with off-road features ğŸš™");
    }
}

public class Sedan implements Car {
    @Override
    public void assemble() {
        System.out.println("Assembling a Sedan with luxury features ğŸš—");
    }
}

public class Hatchback implements Car {
    @Override
    public void assemble() {
        System.out.println("Assembling a Hatchback with compact design ğŸš˜");
    }
}

Step 3: Car Factory

public class CarFactory {
    public Car createCar(String type) {
        if (type == null || type.isEmpty()) {
            return null;
        }
        switch (type.toUpperCase()) {
            case "SUV":
                return new SUV();
            case "SEDAN":
                return new Sedan();
            case "HATCHBACK":
                return new Hatchback();
            default:
                throw new IllegalArgumentException("Unknown car type: " + type);
        }
    }
}

Step 4: Client Code

public class Main {
    public static void main(String[] args) {
        CarFactory factory = new CarFactory();

        Car car1 = factory.createCar("SUV");
        car1.assemble();

        Car car2 = factory.createCar("SEDAN");
        car2.assemble();

        Car car3 = factory.createCar("HATCHBACK");
        car3.assemble();
    }
}


Assembling an SUV with off-road features ğŸš™
Assembling a Sedan with luxury features ğŸš—
Assembling a Hatchback with compact design ğŸš˜

--------------------------------------------------------
Abstract Factory: UIFactory (methods: createButton(), createTextbox())

Concrete Factories: WindowsFactory, MacFactory (apne platform ke components banate hain)

Abstract Products: Button, Textbox (interfaces)

Concrete Products: WindowsButton, MacButton, WindowsTextbox, MacTextbox

// Abstract Products
interface Button {
    void paint();
}

interface Textbox {
    void render();
}

// Concrete Products for Windows
class WindowsButton implements Button {
    public void paint() {
        System.out.println("Rendering Windows style Button");
    }
}

class WindowsTextbox implements Textbox {
    public void render() {
        System.out.println("Rendering Windows style Textbox");
    }
}

// Concrete Products for Mac
class MacButton implements Button {
    public void paint() {
        System.out.println("Rendering Mac style Button");
    }
}

class MacTextbox implements Textbox {
    public void render() {
        System.out.println("Rendering Mac style Textbox");
    }
}

// Abstract Factory
interface UIFactory {
    Button createButton();
    Textbox createTextbox();
}

// Concrete Factory for Windows
class WindowsFactory implements UIFactory {
    public Button createButton() {
        return new WindowsButton();
    }
    public Textbox createTextbox() {
        return new WindowsTextbox();
    }
}

// Concrete Factory for Mac
class MacFactory implements UIFactory {
    public Button createButton() {
        return new MacButton();
    }
    public Textbox createTextbox() {
        return new MacTextbox();
    }
}

// Client code
public class Application {
    private Button button;
    private Textbox textbox;

    public Application(UIFactory factory) {
        button = factory.createButton();
        textbox = factory.createTextbox();
    }

    public void renderUI() {
        button.paint();
        textbox.render();
    }

    public static void main(String[] args) {
        UIFactory factory;

        // Let's say we detect the OS dynamically here (hardcoded for demo)
        String osName = "Windows"; // change to "Mac" to test Mac UI

        if (osName.equals("Windows")) {
            factory = new WindowsFactory();
        } else {
            factory = new MacFactory();
        }

        Application app = new Application(factory);
        app.renderUI();
    }
}
