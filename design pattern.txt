Creational Design Patterns kya hote hain?
Ye design patterns object creation process ko control karte hain, taki code flexible aur reusable ho.
Simple shabdon me â€“ "kaun, kab aur kaise object banayega" â€“ iska control aapke paas hota hai.

ðŸ›  Types of Creational Design Patterns (emoji ke saath)
Singleton Pattern ðŸ 

Concept: Poore system me kisi class ka sirf ek hi object hona chahiye.

Example: Colony ka ek hi paani ka tank ðŸš° â€“ sab waha se paani lete hain.

Benefit: Memory bachta hai aur centralized control milta hai.

Factory Method Pattern ðŸ­

Concept: Object creation ki responsibility ek factory class ko do, taki client ko exact class ka pata na ho.

Example: Pizza shop ðŸ• â€“ aap sirf "Veg" ya "Cheese Burst" bolte ho, kitchen decide karta hai kaunsa pizza class banani hai.

Benefit: Naye product types easily add ho sakte hain bina client code change kiye.

Abstract Factory Pattern ðŸ¢

Concept: Related objects ka poora family banane ke liye factory of factories ka use.

Example: iPhone factory ðŸ“± vs Samsung factory ðŸ“± â€“ dono phone, charger, earphones banate hain but apne-apne style me.

Benefit: Pura product family easily switch kar sakte ho.

Builder Pattern ðŸ§±

Concept: Complex object ko step-by-step build karna.

Example: Subway sandwich ðŸ¥ª â€“ pehle bread, fir vegetables, fir sauce, fir cheeseâ€¦ har step customize hota hai.

Benefit: Object banate waqt zyada flexibility milti hai.

Prototype Pattern ðŸ‘

Concept: Existing object ka clone banake use karna instead of new object creation har bar.

Example: Photocopy machine ðŸ“„ â€“ ek original document se multiple copies ban jati hain bina dobara likhe.

Benefit: Time aur performance dono bachaata hai.

ðŸ“Œ Summary Table
Pattern	Emoji	Real-life Example
Singleton	ðŸ 	Colony ka 1 paani tank
Factory Method	ðŸ­	Pizza shop ðŸ•
Abstract Factory	ðŸ¢	iPhone vs Samsung Factory ðŸ“±
Builder	ðŸ§±	Subway Sandwich ðŸ¥ª
Prototype	ðŸ‘	Photocopy Machine ðŸ“„


---- example for singleton class
// Singleton Class
public class WaterTank {

    private static WaterTank filled; // Lazy initialization (null initially)

    private WaterTank() {
        System.out.println("Paani ka tank ban gaya! ðŸ ðŸš°");
    }

    public static WaterTank fillWater() {
        if (filled == null) { // Object tabhi banega jab pehli baar call hoga
            filled = new WaterTank();
        }
        return filled;
    }

    public void supplyWater() {
        System.out.println("Water used by resident... ðŸ’§");
    }

    public static void main(String[] args) {
        WaterTank user1 = WaterTank.fillWater();
        user1.supplyWater();

        WaterTank user2 = WaterTank.fillWater();
        user2.supplyWater();

        System.out.println("Dono resident ne same water tank se pani bhara? " + (user1 == user2));
    }
}



Note:
Eager Initialization vs Lazy Initialization
Eager initialization: Agar tum object yahi pe create kar dete ho:

private static WaterTank filled = new WaterTank(); 
To class load hote hi tank ban jayega, chahe use ho ya na ho.

Lazy initialization: Tum abhi jaise kar rahe ho:

private static WaterTank filled;
Aur object tabhi create hota hai jab pehli baar fillWater() call hota hai

--------------------
Factory Pattern
Analogy: Car Manufacturing Factory ðŸš—

Socho tum ek car buyer ho. Tum showroom me jaake kehte ho,

â€œMujhe ek SUV chahiyeâ€
ya
â€œMujhe ek Sedan chahiyeâ€

Tum showroom me khud engine, chassis, seats, tyres laga ke car assemble nahi karte.
Instead, factory ke andar ek process hai jo tumhare requirement ke hisaab se car bana ke deta hai.

Tum bas request karte ho type of car ka.

Factory decide karti hai kaunsa model, kaunsa part use hoga, kaise assemble hoga.

Tumhe ready-made product mil jata hai, aur tumhe creation ka detail pata bhi nahi hota.

Programming me kaise match hota hai:

Showroom â†’ Factory class

Customer â†’ Client code

SUV, Sedan â†’ Different subclasses (Car types)

Assembling process â†’ Object creation logic

Client code bas â€œmujhe SUV chahiyeâ€ bolta hai (method call karta hai),
factory poora creation ka headache handle karke final object return kar deta hai.

Isliye is pattern ka motto hota hai:

"Donâ€™t call new directly â€” let the factory build it for you."

Step 1: Common Interface (Car)

public interface Car {
    void assemble();
}

Step 2: Different Car Types

public class SUV implements Car {
    @Override
    public void assemble() {
        System.out.println("Assembling an SUV with off-road features ðŸš™");
    }
}

public class Sedan implements Car {
    @Override
    public void assemble() {
        System.out.println("Assembling a Sedan with luxury features ðŸš—");
    }
}

public class Hatchback implements Car {
    @Override
    public void assemble() {
        System.out.println("Assembling a Hatchback with compact design ðŸš˜");
    }
}

Step 3: Car Factory

public class CarFactory {
    public Car createCar(String type) {
        if (type == null || type.isEmpty()) {
            return null;
        }
        switch (type.toUpperCase()) {
            case "SUV":
                return new SUV();
            case "SEDAN":
                return new Sedan();
            case "HATCHBACK":
                return new Hatchback();
            default:
                throw new IllegalArgumentException("Unknown car type: " + type);
        }
    }
}

Step 4: Client Code

public class Main {
    public static void main(String[] args) {
        CarFactory factory = new CarFactory();

        Car car1 = factory.createCar("SUV");
        car1.assemble();

        Car car2 = factory.createCar("SEDAN");
        car2.assemble();

        Car car3 = factory.createCar("HATCHBACK");
        car3.assemble();
    }
}


Assembling an SUV with off-road features ðŸš™
Assembling a Sedan with luxury features ðŸš—
Assembling a Hatchback with compact design ðŸš˜

--------------------------------------------------------
Abstract Factory: UIFactory (methods: createButton(), createTextbox())

Concrete Factories: WindowsFactory, MacFactory (apne platform ke components banate hain)

Abstract Products: Button, Textbox (interfaces)

Concrete Products: WindowsButton, MacButton, WindowsTextbox, MacTextbox

// Abstract Products
interface Button {
    void paint();
}

interface Textbox {
    void render();
}

// Concrete Products for Windows
class WindowsButton implements Button {
    public void paint() {
        System.out.println("Rendering Windows style Button");
    }
}

class WindowsTextbox implements Textbox {
    public void render() {
        System.out.println("Rendering Windows style Textbox");
    }
}

// Concrete Products for Mac
class MacButton implements Button {
    public void paint() {
        System.out.println("Rendering Mac style Button");
    }
}

class MacTextbox implements Textbox {
    public void render() {
        System.out.println("Rendering Mac style Textbox");
    }
}

// Abstract Factory
interface UIFactory {
    Button createButton();
    Textbox createTextbox();
}

// Concrete Factory for Windows
class WindowsFactory implements UIFactory {
    public Button createButton() {
        return new WindowsButton();
    }
    public Textbox createTextbox() {
        return new WindowsTextbox();
    }
}

// Concrete Factory for Mac
class MacFactory implements UIFactory {
    public Button createButton() {
        return new MacButton();
    }
    public Textbox createTextbox() {
        return new MacTextbox();
    }
}

// Client code
public class Application {
    private Button button;
    private Textbox textbox;

    public Application(UIFactory factory) {
        button = factory.createButton();
        textbox = factory.createTextbox();
    }

    public void renderUI() {
        button.paint();
        textbox.render();
    }

    public static void main(String[] args) {
        UIFactory factory;

        // Let's say we detect the OS dynamically here (hardcoded for demo)
        String osName = "Windows"; // change to "Mac" to test Mac UI

        if (osName.equals("Windows")) {
            factory = new WindowsFactory();
        } else {
            factory = new MacFactory();
        }

        Application app = new Application(factory);
        app.renderUI();
    }
}

| Pattern     | Type       | Purpose                              | Real Life Example                        |
| ----------- | ---------- | ------------------------------------ | ---------------------------------------- |
| **Builder** | Creational | Step-by-step complex object creation | Pizza customization, `StringBuilder`     |
| **Adapter** | Structural | Bridge between incompatible classes  | Mobile charger plug adapter, JDBC driver |

Builder pattern ek creational design pattern hai jo complex objects ko step-by-step construct karne ka tarika deta hai.
Ye pattern construction process ko object ke representation se separate karta hai.

public class StringBuilderExample {
    public static void main(String[] args) {
        // StringBuilder object banaya
        StringBuilder sb = new StringBuilder();

        // Step by step string build karna
        sb.append("Hello");
        sb.append(" ");
        sb.append("World");
        sb.append("!");
        
        // Final result
        System.out.println(sb.toString());
    }
}

Adapter pattern example:
Suppose you have two buddies, one of them speaks French exclusively and the other English exclusively. The language barrier prevents them from communicating the way you want them to.

Target (Interface) â†’ EnglishSpeaker (jo client use karega)

Adaptee â†’ FrenchSpeaker (jo sirf French bolta hai)

Adapter â†’ FrenchToEnglishAdapter (jo French ko English me translate karke connect karega)

// Target Interface
interface EnglishSpeaker {
    void speakEnglish(String words);
}

// Adaptee (French speaker)
class FrenchSpeaker {
    void parlerFrancais(String mots) {
        System.out.println("Parle en FranÃ§ais: " + mots);
    }
}

// Adapter (bridge between French and English)
class FrenchToEnglishAdapter implements EnglishSpeaker {
    private FrenchSpeaker frenchSpeaker;

    public FrenchToEnglishAdapter(FrenchSpeaker frenchSpeaker) {
        this.frenchSpeaker = frenchSpeaker;
    }

    @Override
    public void speakEnglish(String words) {
        // Adapter logic: English â†’ French
        System.out.println("Translating English to French...");
        frenchSpeaker.parlerFrancais(words);
    }
}

// Client code
public class AdapterPatternDemo {
    public static void main(String[] args) {
        // Adaptee object
        FrenchSpeaker frenchGuy = new FrenchSpeaker();

        // Adapter wrapping the French speaker
        EnglishSpeaker adapter = new FrenchToEnglishAdapter(frenchGuy);

        // Client speaks in English, adapter translates
        adapter.speakEnglish("Hello Friend!");
    }
}

ðŸ“Œ Proxy Design Pattern â€“ Notes

Definition:
A structural design pattern that provides a surrogate (stand-in) object which controls access to another object (the real subject).

ðŸ”‘ Key Points

Acts as a middle layer between client and real object.

Used for access control, lazy initialization, logging, caching, remote access.

Follows the same interface as the real object.

Types of Proxy:

Virtual Proxy â†’ loads heavy objects lazily (e.g., images).

Protection Proxy â†’ controls access (e.g., role-based access).

Remote Proxy â†’ represents an object in a different address space (e.g., RMI).

Caching Proxy â†’ returns cached results to improve performance.

ðŸ¦ Real-World Examples

ATM â†’ Bank server (ATM is the proxy).

Credit card â†’ Bank account.

Browser caching images or pages.

âœ… Structure

Subject (Interface) â†’ common contract.

RealSubject â†’ the actual object with core logic.

Proxy â†’ controls access to RealSubject.

Client â†’ uses Subject interface, unaware of Proxy/RealSubject difference.

âš¡ Advantages

Adds security, logging, performance optimization.

Client code stays simple & decoupled.

âš  Disadvantages

Extra layer â†’ slight performance overhead.

Increases complexity.

ðŸ‘‰ One-liner:
Proxy is a design pattern that provides a substitute object to control, enhance, or restrict access to the real object.

Example
// Online Java Compiler
// Use this editor to write, compile and run your Java code online

interface BankAccount {
    void withDraw(String ac, double amount);
}

class RealAccount implements BankAccount {
    @Override
    public void withDraw(String ac, double amount) {
        System.out.println("Withdrawing " + amount + " from account: " + ac);
    }
}

class ProxyAccount implements BankAccount {
    private RealAccount realAccount;
    private String role;
    
    ProxyAccount(String role){
        this.role = role;
        realAccount = new RealAccount();
    }
    
    @Override
    public void withDraw(String ac, double amount) {
        if(role == "ADMIN")
        {
           realAccount.withDraw(ac, amount); 
        }
        else {
            System.out.println("role is not permitted");
        }
    }
}
class Main {
    public static void main(String[] args) {
       BankAccount ba = new ProxyAccount("ADMIN");
       ba.withDraw("1234",5000);
       BankAccount ba1 = new ProxyAccount("USER");
       ba1.withDraw("1234",50000);
    }
}
----------------
Decorator design pattern:
Decorator Design Pattern â€“ Short Notes

Type: Structural Design Pattern

Definition: Attaches additional responsibilities to an object dynamically.
Open/Closed Principle Recap

Open for extension â†’ You can extend an objectâ€™s behavior.

Closed for modification â†’ You donâ€™t need to change the existing class code.

Analogy: Wrapping a gift box â€“ each wrapper adds something new without changing the original gift.

Key Components

Component â†’ Interface/abstract class defining behavior.

Concrete Component â†’ Base object with default behavior.

Decorator (abstract) â†’ Holds reference to a component, implements the same interface.

Concrete Decorators â†’ Extend functionality by overriding methods.

Advantages

Adds behavior at runtime (flexible than inheritance).

Promotes open/closed principle (open for extension, closed for modification).

Avoids class explosion caused by multiple subclasses.

Disadvantages

Can result in many small classes.

Debugging can be harder due to multiple layers of wrapping.

Example

Coffee Shop: SimpleCoffee + decorators like Milk, Sugar, WhippedCream.

Java I/O Streams: BufferedInputStream(new FileInputStream("file.txt")).

ðŸ‘‰ Use when: You need to add/remove features dynamically without altering the base class.

Example:
// Online Java Compiler
// Use this editor to write, compile and run your Java code online

interface Coffee {
    String getDescription();
    double getCost();
}

class PlainCoffee implements Coffee {
    @Override
    public String getDescription() {
        return "Simple Coffee";
    }
    
    @Override
    public double getCost() {
        return 5.0;
    }
}

abstract class CoffeeDecorator implements Coffee {
    protected Coffee coffee;
    CoffeeDecorator(Coffee coffee) {
        this.coffee = coffee;
    }
    
    public String getDescription() {
        return coffee.getDescription();
    }
    
    public double getCost() {
        return coffee.getCost();
    }
}

class MilkDecorator extends CoffeeDecorator {
    public MilkDecorator(Coffee coffee) {
        super(coffee);
    }
    
    public String getDescription() {
        return coffee.getDescription() + ", Milk";
    }
    
    public double getCost() {
        return coffee.getCost() + 1.5;
    }
}

class WhippedCreamDecorator extends CoffeeDecorator {
    public WhippedCreamDecorator(Coffee coffee) {
        super(coffee);
    }
    
    public String getDescription() {
        return coffee.getDescription() + ", Cream";
    }
    
    public double getCost() {
        return coffee.getCost() + 1;
    }
}

class SugarDecorator extends CoffeeDecorator {
    public SugarDecorator(Coffee coffee) {
        super(coffee);
    }
    
    public String getDescription() {
        return coffee.getDescription() + ", Sugar";
    }
    
    public double getCost() {
        return coffee.getCost() + 1;
    }
}


class Main {
    public static void main(String[] args) {
      Coffee coffee = new PlainCoffee();
      coffee = new MilkDecorator(coffee);
      System.out.println(coffee.getDescription() + " -> $" + coffee.getCost());
      coffee = new SugarDecorator(coffee);
      System.out.println(coffee.getDescription() + " -> $" + coffee.getCost());
      coffee = new WhippedCreamDecorator(coffee);
      System.out.println(coffee.getDescription() + " -> $" + coffee.getCost());
    }
}

------------------
Facade Design Pattern â€“ Short Notes

Type: Structural Design Pattern

Definition: Provides a unified, simplified interface to a set of complex subsystems.

Analogy: Universal remote control â€“ hides the complexity of multiple devices.

Key Points

Hides subsystem complexity from clients.

Client interacts with one facade object instead of multiple subsystem classes.

Subsystems remain unchanged; facade only orchestrates calls.

Promotes loose coupling between client and subsystems.

SOLID Principles

SRP: Facade has one job â†’ simplify subsystem usage.

DIP: Client depends on Facade (abstraction), not on subsystem details.

Advantages

Simplifies client code.

Reduces dependency between client and subsystems.

Makes the system easier to use.

Disadvantages

Can become a god object if it grows too much.

May hide too much flexibility of subsystems.

Real-Time Examples

Home Theater System: watchMovie() hides projector, DVD, sound setup.

Banking App: transferMoney() hides authentication, debit/credit, logging, notifications.

Java Libraries:

javax.faces.context.FacesContext (JSF)

java.net.URL (hides sockets, protocols, DNS handling)

Springâ€™s JdbcTemplate (hides JDBC boilerplate).

ðŸ‘‰ In short: Facade makes complex things simple for the client without changing the subsystems.

Example
// Subsystem classes
class AuthenticationService {
    public boolean authenticate(String userId, String password) {
        System.out.println("Authenticating user: " + userId);
        return true; // assume always valid
    }
}

class AccountService {
    public boolean checkBalance(String accountId, double amount) {
        System.out.println("Checking balance for " + accountId);
        return true;
    }

    public void debit(String accountId, double amount) {
        System.out.println("Debiting " + amount + " from " + accountId);
    }

    public void credit(String accountId, double amount) {
        System.out.println("Crediting " + amount + " to " + accountId);
    }
}

class TransactionLogger {
    public void log(String message) {
        System.out.println("Transaction Log: " + message);
    }
}

class NotificationService {
    public void notifyUser(String userId, String message) {
        System.out.println("Notifying " + userId + ": " + message);
    }
}

// Facade
class BankingFacade {
    private AuthenticationService authService;
    private AccountService accountService;
    private TransactionLogger logger;
    private NotificationService notifier;

    public BankingFacade() {
        this.authService = new AuthenticationService();
        this.accountService = new AccountService();
        this.logger = new TransactionLogger();
        this.notifier = new NotificationService();
    }

    public void transferMoney(String userId, String password, 
                              String fromAcc, String toAcc, double amount) {
        if (authService.authenticate(userId, password) 
            && accountService.checkBalance(fromAcc, amount)) {
            
            accountService.debit(fromAcc, amount);
            accountService.credit(toAcc, amount);
            logger.log("Transfer of " + amount + " from " + fromAcc + " to " + toAcc);
            notifier.notifyUser(userId, "Transfer Successful: " + amount);
        } else {
            System.out.println("Transfer failed!");
        }
    }
}

public class FacadeBankingDemo {
    public static void main(String[] args) {
        BankingFacade bankingFacade = new BankingFacade();
        bankingFacade.transferMoney("user123", "password", "ACC1001", "ACC2002", 500.0);
    }
}
-------------
blueprint for adapter design pattern
// 1. Target interface (expected by client)
interface Target {
    void request();
}

// 2. Adaptee (legacy / incompatible class)
class Adaptee {
    public void specificRequest() {
        System.out.println("Called specificRequest() from Adaptee");
    }
}

// 3. Adapter (makes Adaptee compatible with Target)
class Adapter implements Target {
    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        // Translate request into Adaptee's method
        adaptee.specificRequest();
    }
}

// 4. Client (uses Target interface)
public class AdapterPatternDemo {
    public static void main(String[] args) {
        Adaptee adaptee = new Adaptee();
        
        // Wrap adaptee in an adapter
        Target target = new Adapter(adaptee);
        
        // Client uses Target interface
        target.request();
    }
}

-----------------
blue print for proxy design pattern
// 1. Subject (common interface)
interface Subject {
    void request();
}

// 2. RealSubject (actual implementation)
class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("RealSubject: Handling the request.");
    }
}

// 3. Proxy (controls access to RealSubject)
class Proxy implements Subject {
    private RealSubject realSubject;

    @Override
    public void request() {
        if (realSubject == null) {
            realSubject = new RealSubject(); // Lazy initialization
        }

        System.out.println("Proxy: Performing access control or logging before delegating.");
        realSubject.request();
    }
}

// 4. Client
public class ProxyPatternDemo {
    public static void main(String[] args) {
        Subject proxy = new Proxy();

        // Client calls proxy instead of directly using RealSubject
        proxy.request();
    }
}
----------------
blueprint for facade design pattern
// 1. Subsystem classes
class SubsystemA {
    void operationA() {
        System.out.println("SubsystemA: operationA executed");
    }
}

class SubsystemB {
    void operationB() {
        System.out.println("SubsystemB: operationB executed");
    }
}

class SubsystemC {
    void operationC() {
        System.out.println("SubsystemC: operationC executed");
    }
}

// 2. Facade (simplifies subsystem usage)
class Facade {
    private SubsystemA subsystemA;
    private SubsystemB subsystemB;
    private SubsystemC subsystemC;

    public Facade() {
        this.subsystemA = new SubsystemA();
        this.subsystemB = new SubsystemB();
        this.subsystemC = new SubsystemC();
    }

    // Unified method that hides complexity
    public void simpleOperation() {
        System.out.println("Facade: Coordinating subsystems...");
        subsystemA.operationA();
        subsystemB.operationB();
        subsystemC.operationC();
    }
}

// 3. Client
public class FacadePatternDemo {
    public static void main(String[] args) {
        Facade facade = new Facade();
        
        // Client calls only the Facade method
        facade.simpleOperation();
    }
}

-----------------
blueprint for decorator design pattern
// 1. Component
interface Component {
    void operation();
}

// 2. Concrete Component
class ConcreteComponent implements Component {
    @Override
    public void operation() {
        System.out.println("ConcreteComponent: Base operation");
    }
}

// 3. Decorator (abstract class)
abstract class Decorator implements Component {
    protected Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    @Override
    public void operation() {
        component.operation(); // delegate to wrapped object
    }
}

// 4. Concrete Decorators
class ConcreteDecoratorA extends Decorator {
    public ConcreteDecoratorA(Component component) {
        super(component);
    }

    @Override
    public void operation() {
        super.operation(); // call base behavior
        System.out.println("ConcreteDecoratorA: Added behavior A");
    }
}

class ConcreteDecoratorB extends Decorator {
    public ConcreteDecoratorB(Component component) {
        super(component);
    }

    @Override
    public void operation() {
        super.operation(); // call base behavior
        System.out.println("ConcreteDecoratorB: Added behavior B");
    }
}

// 5. Client
public class DecoratorPatternDemo {
    public static void main(String[] args) {
        Component component = new ConcreteComponent();

        // Wrap with DecoratorA
        Component decoratedA = new ConcreteDecoratorA(component);

        // Wrap with DecoratorB on top of DecoratorA
        Component decoratedB = new ConcreteDecoratorB(decoratedA);

        // Call operation
        decoratedB.operation();
    }
}

